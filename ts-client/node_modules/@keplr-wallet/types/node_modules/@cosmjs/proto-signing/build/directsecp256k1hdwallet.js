"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectSecp256k1HdWallet = void 0;
const crypto_1 = require("@cosmjs/crypto");
const launchpad_1 = require("@cosmjs/launchpad");
const paths_1 = require("./paths");
const signing_1 = require("./signing");
/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */
class DirectSecp256k1HdWallet {
    constructor(mnemonic, hdPath, privkey, pubkey, prefix) {
        this.secret = mnemonic;
        this.accounts = [
            {
                hdPath: hdPath,
                prefix: prefix,
            },
        ];
        this.privkey = privkey;
        this.pubkey = pubkey;
    }
    /**
     * Restores a wallet from the given BIP39 mnemonic.
     *
     * @param mnemonic Any valid English mnemonic.
     * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.
     * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
     */
    static async fromMnemonic(mnemonic, hdPath = paths_1.makeCosmoshubPath(0), prefix = "cosmos") {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked);
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, seed, hdPath);
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new DirectSecp256k1HdWallet(mnemonicChecked, hdPath, privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
    }
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.
     * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
     */
    static async generate(length = 12, hdPath = paths_1.makeCosmoshubPath(0), prefix = "cosmos") {
        const entropyLength = 4 * Math.floor((11 * length) / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), hdPath, prefix);
    }
    get mnemonic() {
        return this.secret.toString();
    }
    get address() {
        return launchpad_1.rawSecp256k1PubkeyToAddress(this.pubkey, this.accounts[0].prefix);
    }
    async getAccounts() {
        return [
            {
                algo: "secp256k1",
                address: this.address,
                pubkey: this.pubkey,
            },
        ];
    }
    async signDirect(address, signDoc) {
        const signBytes = signing_1.makeSignBytes(signDoc);
        if (address !== this.address) {
            throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = crypto_1.sha256(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = launchpad_1.encodeSecp256k1Signature(this.pubkey, signatureBytes);
        return {
            signed: signDoc,
            signature: stdSignature,
        };
    }
}
exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
//# sourceMappingURL=directsecp256k1hdwallet.js.map