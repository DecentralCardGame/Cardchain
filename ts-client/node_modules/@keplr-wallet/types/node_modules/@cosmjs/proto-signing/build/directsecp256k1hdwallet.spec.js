"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const directsecp256k1hdwallet_1 = require("./directsecp256k1hdwallet");
const signing_1 = require("./signing");
const testutils_spec_1 = require("./testutils.spec");
describe("DirectSecp256k1HdWallet", () => {
    // m/44'/118'/0'/0/0
    // pubkey: 02baa4ef93f2ce84592a49b1d729c074eab640112522a7a89f7d03ebab21ded7b6
    const defaultMnemonic = "special sign fit simple patrol salute grocery chicken wheat radar tonight ceiling";
    const defaultPubkey = encoding_1.fromHex("02baa4ef93f2ce84592a49b1d729c074eab640112522a7a89f7d03ebab21ded7b6");
    const defaultAddress = "cosmos1jhg0e7s6gn44tfc5k37kr04sznyhedtc9rzys5";
    describe("fromMnemonic", () => {
        it("works", async () => {
            const wallet = await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.fromMnemonic(defaultMnemonic);
            expect(wallet).toBeTruthy();
            expect(wallet.mnemonic).toEqual(defaultMnemonic);
        });
    });
    describe("generate", () => {
        it("defaults to 12 words", async () => {
            const wallet = await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate();
            expect(wallet.mnemonic.split(" ").length).toEqual(12);
        });
        it("can use different mnemonic lengths", async () => {
            expect((await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate(12)).mnemonic.split(" ").length).toEqual(12);
            expect((await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate(15)).mnemonic.split(" ").length).toEqual(15);
            expect((await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate(18)).mnemonic.split(" ").length).toEqual(18);
            expect((await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate(21)).mnemonic.split(" ").length).toEqual(21);
            expect((await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.generate(24)).mnemonic.split(" ").length).toEqual(24);
        });
    });
    describe("getAccounts", () => {
        it("resolves to a list of accounts", async () => {
            const wallet = await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.fromMnemonic(defaultMnemonic);
            const accounts = await wallet.getAccounts();
            expect(accounts.length).toEqual(1);
            expect(accounts[0]).toEqual({
                address: defaultAddress,
                algo: "secp256k1",
                pubkey: defaultPubkey,
            });
        });
        it("creates the same address as Go implementation", async () => {
            const wallet = await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.fromMnemonic("oyster design unusual machine spread century engine gravity focus cave carry slot");
            const [{ address }] = await wallet.getAccounts();
            expect(address).toEqual("cosmos1cjsxept9rkggzxztslae9ndgpdyt2408lk850u");
        });
    });
    describe("signDirect", () => {
        it("resolves to valid signature", async () => {
            const { accountNumber, sequence, bodyBytes } = testutils_spec_1.testVectors[1].inputs;
            const wallet = await directsecp256k1hdwallet_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const pubkey = {
                typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                value: encoding_1.fromBase64(testutils_spec_1.faucet.pubkey.value),
            };
            const fee = launchpad_1.coins(2000, "ucosm");
            const gasLimit = 200000;
            const chainId = "simd-testing";
            const signDoc = signing_1.makeSignDoc(encoding_1.fromHex(bodyBytes), signing_1.makeAuthInfoBytes([pubkey], fee, gasLimit, sequence), chainId, accountNumber);
            const signDocBytes = signing_1.makeSignBytes(signDoc);
            const { signature } = await wallet.signDirect(testutils_spec_1.faucet.address, signDoc);
            const valid = await crypto_1.Secp256k1.verifySignature(crypto_1.Secp256k1Signature.fromFixedLength(encoding_1.fromBase64(signature.signature)), crypto_1.sha256(signDocBytes), pubkey.value);
            expect(valid).toEqual(true);
        });
    });
});
//# sourceMappingURL=directsecp256k1hdwallet.spec.js.map